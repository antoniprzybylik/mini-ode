use pyo3::prelude::*;
use pyo3::types::PyType;
use pyo3_tch::PyTensor;
use std::io::Cursor;

#[pyfunction]
fn solve_euler(py: Python, f: PyObject, x_span: PyTensor, y0: PyTensor, step: PyTensor) -> PyResult<(PyTensor, PyTensor)> {
    let torch = py.import("torch")?;
    let script_function_type = torch.getattr("jit")?.getattr("ScriptFunction")?.downcast::<PyAny>()?;
    
    if !f.downcast::<PyAny>(py)?.is_instance(script_function_type)? {
        return Err(pyo3::exceptions::PyTypeError::new_err("Expected `f` to be of torch.jit.ScriptFunction type."));
    }

    let io_mod = py.import("io")?;
    let io = io_mod.getattr("BytesIO")?.call0()?;
    let buffer = f.downcast::<PyAny>(py)?.call_method0("save_to_buffer")?.extract::<Vec<u8>>()?;
    //let buffer = io.call_method0("getvalue")?.extract::<Vec<u8>>()?;

    let mut cursor = Cursor::new(buffer);
    let f_cmodule = tch::CModule::load_data(&mut cursor).map_err(|e| {
        pyo3::exceptions::PyRuntimeError::new_err(format!("Failed to load CModule: {}", e))
    })?;

    mini_ode::solve_euler(
        f_cmodule,
        x_span.0,
        y0.0,
        step.0
    ).map(|ok| {
        (PyTensor(ok.0), PyTensor(ok.1))
    }).map_err(|e| {
        pyo3::exceptions::PyRuntimeError::new_err(format!("{}", e))
    })
}

#[pymodule]
#[pyo3(name = "rust")]
fn init_module(m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_function(wrap_pyfunction!(solve_euler, m)?);
    m.add("__version__", env!("CARGO_PKG_VERSION"))?;

    Ok(())
}
