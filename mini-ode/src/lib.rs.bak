use tch::Tensor;
use tch::IndexOp;
use anyhow::anyhow;

/// Solves ODE using Euler method
pub fn solve_euler(f: tch::CModule, x_span: Tensor, y0: Tensor, step: Tensor) -> anyhow::Result<(Tensor, Tensor)>{
    if x_span.size() != vec![2] {
        return Err(anyhow!("`x_span` must be of shape 2"));
    }

    if y0.size().len() != 1 {
        return Err(anyhow!("`y0` must be a one-dimensional tensor"));
    }

    if step.size().len() != 0 {
        return Err(anyhow!("`step` must be a zero-dimensional tensor"));
    }

    let x_start: Tensor = x_span.i(0);
    let x_end: Tensor = x_span.i(1);

    let mut x = x_start.unsqueeze(0);
    let mut y = y0.unsqueeze(0);

    let mut all_x: Vec::<Tensor> = vec![x.copy()];
    let mut all_y: Vec::<Tensor> = vec![y.copy()];

    let mut step = step;
    while x.lt_tensor(&x_end) == tch::Tensor::from_slice(&[true]) {
        if (&x_end - &x).lt_tensor(&step) == tch::Tensor::from_slice(&[true]) {
            step = &x_end - &x;
        }

        y = &y + &step*f.forward_ts(&[x.copy(), y.copy()])?;
        x = &x + &step;
        all_y.push(y.copy());
        all_x.push(x.copy());
    }

    return Ok((Tensor::cat(&all_x, 0), Tensor::cat(&all_y, 0)))
}
